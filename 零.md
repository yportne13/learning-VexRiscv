# VexRiscv 简单解析（零）：先从一个简单的 riscv 核开始

[VexRiscv](https://github.com/SpinalHDL/VexRiscv) 是一个开源的 Riscv 处理器。和其他开源处理器相比，VexRiscv 最大的亮点在于其大概是目前最强大的参数化能力和添加自定义扩展指令的能力。使用的是 CHISEL 家族中大概是生成代码可读性最高的 SpinalHDL 编写而成。目前已开源的部分支持RV32I/E[M][A][F[D]][C][B][K]（中括号内为可由参数控制是否生成）。

虽然 VexRiscv 是一个质量非常高的开源代码，也是 github 上 star 数前几的 riscv 处理器，但似乎有很多人在阅读 VexRiscv 代码上存在一些困难，因此本系列文章的主要目的就是帮助缕清代码的脉络。笔者能力有限，难免会有错误，望各位大佬指正。

本系列文章适合对 spinalhdl 有一定基础的使用者阅读。

在对 Riscv 的 cpu 架构不太了解的情况下直接看 VexRiscv 的代码比较困难，因此先让我们看看一个相对简单一些的 riscv cpu 的代码。这个代码在 SpinalHDL 的 lib 库中 [代码链接](https://github.com/SpinalHDL/SpinalHDL/blob/dev/lib/src/main/scala/spinal/lib/cpu/riscv/impl/RiscvCore.scala)

## 参数及接口

前面一大段主要是接口定义啥的，让我们直接跳到 475 行看顶层模块。

```scala
class RiscvCore(implicit val c : RiscvCoreConfig) extends Component{
  import c._
```

`implicit val` 隐式值，调用它的时候不需要写出来，会自动去找你定义的值。效果如下：

```scala
SpinalVhdl{
      implicit val p = RiscvCoreConfig(
        ...
      )
      (new RiscvCore).setDefinitionName("TopLevel")
    }
```

`import c._` 后续在调用 c 里的内容时（例如调用 pcWidth），可以直接写 `pcWidth` 而无需写 `c.pcWidth`。

```scala
  //Instruction bus
  val iCmd = Stream(CoreInstructionCmd())
  val iRsp = Stream(CoreInstructionRsp())

  //Data bus
  val dCmd = Stream(CoreDataCmd())
  val dRsp = Stream(Bits(32 bits))
  val dataBusKind : DataBusKind = if(c.extensions.foldLeft(false)(_ || _.needFlowDRsp))
    cmdStream_rspFlow
  else
    cmdStream_rspStream
```

定义指令总线和数据总线。cmd(command)命令 rsp(response)响应

有待补充

## prefetch

prefetch 阶段主要完成的是计算取指令的地址 `pc`。基础的 RV32I 指令是 32 位的，也就是 4 个字节，因此在程序正常顺序执行时，每次指令地址加 4 即可。但当遇见无条件跳转指令（Jump & Link）和条件分支指令（Branches）时指令地址则需要随之改变。这一阶段并未处理遇见条件指令时的需要跳转到的地址，仅定义了 `pcLoad` 信号，具体行为在完成所有阶段的操作后才完善。

## fetch



## decode

译码阶段。RiscV 的指令共有六种类型：


## execute0

执行阶段

## execute1



## writeback

写回阶段，
